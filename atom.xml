<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[CCI]]></title>
  <link href="http://TakahiroHaruyama.github.io/atom.xml" rel="self"/>
  <link href="http://TakahiroHaruyama.github.io/"/>
  <updated>2014-03-24T22:51:05+09:00</updated>
  <id>http://TakahiroHaruyama.github.io/</id>
  <author>
    <name><![CDATA[Takahiro Haruyama (@cci_forensics)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[ID/IDAPython scripts extracting PlugX configs]]></title>
    <link href="http://TakahiroHaruyama.github.io/blog/2014/03/27/id-slash-idapython-scripts-extracting-plugx-configs/"/>
    <updated>2014-03-27T00:00:00+09:00</updated>
    <id>http://TakahiroHaruyama.github.io/blog/2014/03/27/id-slash-idapython-scripts-extracting-plugx-configs</id>
    <content type="html"><![CDATA[<p>I release Immunity Debugger and IDAPython scirpts dumping PlugX configs (and original PEs) then parsing them.</p>

<!-- more -->


<p>IIJ-SECT (CSIRT team at IIJ, Inc.) classifies PlugX samples into 3 types: type I/II/III. In more detail, check <a href="https://www.blackhat.com/asia-14/briefings.html#Haruyama">our presentation</a>.
The Immunity Debugger script can be used for PlugX type I&amp;II. The IDAPython script can parse type III configs.</p>

<h3>Distinction between Type I&amp;II and III</h3>

<p>Before using the scripts, we should guess which type the PlugX specimen is. Generally, type I/II injects their codes twice: the 1st target process defined in the config and msiexec. The 1st target process may be svchost/msiexec/iexplore/winlogon like the following figures. However, some samples don&rsquo;t inject according to the config (stand-alone flag), additionally, other several specimens inject only once. So, the criteria is ambiguous. Moreover, in my experience, Type III is usually executed by rundll32.</p>

<p><img src="http://TakahiroHaruyama.github.io/images/post/plugx_scripts/type_diff_process.PNG" alt="type_diff_process" /></p>

<h3>ID Script for Type I&amp;II</h3>

<p>We need to copy the ID script into PyCommands folder in advance. Then we attach to one of injected processes. After attaching to the process, run the script (!plugx_dumper). If successful, the parsed config is displayed in Log View. The result and decompressed original PE file are saved in the same folder.</p>

<p><img src="http://TakahiroHaruyama.github.io/images/post/plugx_scripts/ID_result.PNG" alt="ID_result" /></p>

<p>If the following message is output, the specimen may be neither type I nor II.</p>

<p><img src="http://TakahiroHaruyama.github.io/images/post/plugx_scripts/ID_failed.png" alt="ID_failed" /></p>

<h3>IDAPython Script for Type III</h3>

<p>Since type III variants are more obfuscated (e.g., massive obfuscated strings, inserted random junk codes), it&rsquo;s difficult to extract the config from process memory. Therefore, I wrote an IDAPython script for parsing type III configs.</p>

<p>To use the script, we must find the function to decode obfuscated strings and set it as decode_function_name in the script. It may be an obstacle for DFIR people not reverse-engineering malware.</p>

<p><img src="http://TakahiroHaruyama.github.io/images/post/plugx_scripts/IDA_prepare.PNG" alt="IDA_prepare" /></p>

<p>After the configuration, run the script. We can check the result in Output window. Parsed config information is saved as &ldquo;config.txt&rdquo;.</p>

<p><img src="http://TakahiroHaruyama.github.io/images/post/plugx_scripts/IDA_result.PNG" alt="IDA_result" /></p>

<h3>Note: Demo Version</h3>

<p>PlugX demo specimens (some demo samples pop-up &ldquo;THIS IS A DEMO VERSION!!!&rdquo;, others not) do not include config data. When detecting the specimen is demo version, the scripts notify us of the result like this. The configs are filled by &ldquo;XXXX&rdquo; in demo samples.</p>

<p><img src="http://TakahiroHaruyama.github.io/images/post/plugx_scripts/Demos.PNG" alt="Demos" /></p>

<h3>Download</h3>

<ul>
<li><a href="http://TakahiroHaruyama.github.io/downloads/scripts/plugx_dumper.py">Immunity Debugger script for type I&amp;II</a> (Supported config sizes are 0x150C/0x1510/0x1B18/0x1D18/0x2540)</li>
<li><a href="http://TakahiroHaruyama.github.io/downloads/scripts/plugx_config_dumper_IDA.py">IDAPython script for type III</a> (Supported config sizes are 0x72C/0x76C/0xDF0/0x7AC/0x840)</li>
</ul>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[PlugX Builder/Controller (Type III, 0x840)]]></title>
    <link href="http://TakahiroHaruyama.github.io/blog/2014/03/12/plugx-builder-slash-controller/"/>
    <updated>2014-03-12T19:44:27+09:00</updated>
    <id>http://TakahiroHaruyama.github.io/blog/2014/03/12/plugx-builder-slash-controller</id>
    <content type="html"><![CDATA[<p>Recently, I acquired a PlugX builder/controller. This seems to be the same as the one referred in <a href="http://image.ahnlab.com/global/upload/download/documents/1401223631603288.pdf">AhnLab&rsquo;s APT attacks analysis report</a>, judging from the GUI window. I tried to use it.</p>

<!-- more -->


<p>This PlugX version (we call it &ldquo;TypeIII&rdquo;) supports custom DNS servers.</p>

<p><img src="http://TakahiroHaruyama.github.io/images/post/plugx_dns.PNG" alt="plugx_dns" /></p>

<p>The service information like service(or dll) name and service description is simpler than Type I/II.</p>

<p><img src="http://TakahiroHaruyama.github.io/images/post/PlugX_ServiceInfo.PNG" alt="PlugX_ServiceInfo" /></p>

<p>The controller also provides online status of victims.</p>

<p><img src="http://TakahiroHaruyama.github.io/images/post/PlugX_online.PNG" alt="PlugX_online" /></p>

<h3>Why two &ldquo;Build&rdquo; buttons?</h3>

<p>The funny thing is that there are two kinds of &ldquo;build&rdquo; buttons in this builder.
That&rsquo;s because type III specimens merge C2 setting, C2 setting URL (which is the location of DZKS/DZJS encoded file/text), proxy setting into 1 structure.</p>

<p>C2 setting tab</p>

<p><img src="http://TakahiroHaruyama.github.io/images/post/PlugX_C2Setting.PNG" alt="PlugX_C2Setting" /></p>

<p>C2 setting URL tab</p>

<p><img src="http://TakahiroHaruyama.github.io/images/post/PlugX_C2SettingURL.PNG" alt="PlugX_C2SettingURL" /></p>

<p>The built sample includes only either C2 setting or C2 setting URL. If you build in C2Setting tab, the sample includes only C2Setting information, vice versa. The size is fixed 0x840 bytes.</p>

<p><img src="http://TakahiroHaruyama.github.io/images/post/PlugX_parsedConfig.PNG" alt="PlugX_parsedConfig" /></p>

<p>The config parser will be released after <a href="https://www.blackhat.com/asia-14/briefings.html#Haruyama">Black Hat Asia 2014 conference</a> (I will also explain type I/II/III behavior, besides, co-author Hiroshi Suzuki will show the relationships between PlugX samples and attack groups)</p>

<h3>Supported Commands</h3>

<p>And once connected by a victim, I can open the command window.</p>

<p><img src="http://TakahiroHaruyama.github.io/images/post/PlugX_commands.PNG" alt="PlugX_commands" /></p>

<p>I&rsquo;m surprised RAT version is different from the controller version.</p>

<p>The supported commands and functions are:</p>

<ul>
<li>Disk Management</li>
<li>File Transfer</li>
<li>Process Management</li>
<li>Service Management</li>
<li>Registry Management</li>
<li>Screenshot</li>
<li>Remote Control</li>
<li>DOS command</li>
<li>Port Mapping</li>
<li>Keylogger</li>
<li>Local Log</li>
<li>Remote log</li>
</ul>


<h3>The hash values</h3>

<p>SHA256=de7a97efe1fd0aff0a90f703becc9162124ee86901a1ad57bcf5d2884c2235d2
MD5=b4d8bfb56accbd17514bffc1fa8e1953</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[64bit big sized RAM Image Acquisition Problem]]></title>
    <link href="http://TakahiroHaruyama.github.io/blog/2014/01/07/64bit-big-size-ram-acquisition-problem/"/>
    <updated>2014-01-07T22:15:39+09:00</updated>
    <id>http://TakahiroHaruyama.github.io/blog/2014/01/07/64bit-big-size-ram-acquisition-problem</id>
    <content type="html"><![CDATA[<h3>The Problem</h3>

<p>One day, I acquired a 16GB raw memory image on Windows7 x64 machine using MoonSols DumpIt for malware investigation. Then I tried to analyze it using Volatility Framework and Redline, but they returned no output like this:</p>

<p><img src="http://TakahiroHaruyama.github.io/images/post/vol_no_result.jpg" alt="vol_no_result" /></p>

<p>I guessed the acquired image was corrupted, so I took an image again, but the result was the same. I googled about the problem and found <a href="https://code.google.com/p/volatility/issues/detail?id=412">a similar issue</a>. According to the report, I tested several memory acquisition tools such as FTK Imager and Windows Memory Reader, but they didn&rsquo;t work.</p>

<p>I changed an image format from raw to crashdump. Then Volatility Framework could parse it and display the result. Strangely, Volatility also could analyze the raw image converted from the crashdump. Where does this difference come from?</p>

<!-- more -->


<h3>The Cause</h3>

<p>I debugged Volatility and noticed it could not find _KDDEBUGGER_DATA64 structure.</p>

<figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>def get_kdbg(addr_space):
</span><span class='line'>    """A function designed to return the KDBG structure from 
</span><span class='line'>    an address space. First we try scanning for KDBG and if 
</span><span class='line'>    that fails, we try scanning for KPCR and bouncing back to
</span><span class='line'>    KDBG from there. 
</span><span class='line'>
</span><span class='line'>    Also note, both the primary and backup methods rely on the 
</span><span class='line'>    4-byte KDBG.Header.OwnerTag. If someone overwrites this 
</span><span class='line'>    value, then neither method will succeed. The same is true 
</span><span class='line'>    even if a user specifies --kdbg, because we check for the 
</span><span class='line'>    OwnerTag even in that case. 
</span><span class='line'>    """
</span><span class='line'>
</span><span class='line'>    kdbgo = obj.VolMagic(addr_space).KDBG.v()
</span><span class='line'>
</span><span class='line'>    kdbg = obj.Object("\_KDDEBUGGER_DATA64", offset = kdbgo, vm = addr_space) 
</span><span class='line'>
</span><span class='line'>    if kdbg.is_valid(): # &lt;- failed
</span><span class='line'>        return kdbg
</span><span class='line'>
</span><span class='line'>    # Fall back to finding it via the KPCR. We cannot
</span><span class='line'>    # accept the first/best suggestion, because only 
</span><span class='line'>    # the KPCR for the first CPU allows us to find KDBG. 
</span><span class='line'>    for kpcr_off in obj.VolMagic(addr_space).KPCR.generate_suggestions():
</span><span class='line'>        
</span><span class='line'>        kpcr = obj.Object("_KPCR", offset = kpcr_off, vm = addr_space)
</span><span class='line'>
</span><span class='line'>        kdbg = kpcr.get_kdbg() 
</span><span class='line'>    
</span><span class='line'>        if kdbg.is_valid(): # &lt;- failed
</span><span class='line'>            return kdbg
</span><span class='line'>
</span><span class='line'>    return obj.NoneObject("KDDEBUGGER structure not found using either KDBG signature or KPCR pointer")</span></code></pre></td></tr></table></div></figure>


<p>_KDDEBUGGER_DATA64 includes various debug information like PsLoadedModuleList. Matthieu Suiche at MoonSols told me Vista or later Windows OSes on x64 machines encrypt the structure. So I compared a simply-dumped raw image with a raw image converted from crashdump.</p>

<p><img src="http://TakahiroHaruyama.github.io/images/post/DBGKD_DEBUG_DATA_HEADER64.jpg" alt="kdbg_encrypted" /></p>

<p>DBGKD_DEBUG_DATA_HEADER64 in _KDDEBUGGER_DATA64 is highlighted. Surely, it seems to be encoded by a specific algorithm. I think there is a few people knowing the fact because <strong>the encryption is only applied to big size RAM</strong> (if not correct, please let me know). For instance, I checked _KDDEBUGGER_DATA64 in 1GB raw image was not encrypted and analysis tools worked fine.</p>

<h3>Which acquisition tools should we use?</h3>

<p>Matthieu said DumpIt implemented the decryption of _KDDEBUGGER_DATA64 structure for crashdump format only. I investigated whether acquisition tools including DumpIt can decrypt the structure. I showed the result in the folowing table.</p>

<p><img src="http://TakahiroHaruyama.github.io/images/post/acquisition_tools_result.png" alt="acquisition_tools_result" /></p>

<p>The result means the only option is to take crashdump using DumpIt. Any other tools don&rsquo;t decrypt. So, why DumpIt can decrypt the structure? I reverse-engineered the driver code and found it used KdSystemDebugControl to get _DBGKD_GET_VERSION64 and _KDDEBUGGER_DATA64, then made its crashdump header (1st page in .dmp) manually by inserting _KDDEBUGGER_DATA64 member values, but I couldn&rsquo;t find the decryption routine by static code analysis. The local debugging API is related to the decryption? not sure.</p>

<p><img src="http://TakahiroHaruyama.github.io/images/post/KdSystemDebugControl.jpg" alt="KdSystemDebugControl" /></p>

<h3>Just for the record,</h3>

<p>64-bit crashdump images generated by Windows Memory Reader and winpmem couldn&rsquo;t be analyzed by my EnScript, CrashDumpAnalyzer. I cannot understand the error because my EnScript reads debug information from the 1st header, so the EnScript is due to parse it even if _KDDEBUGGER_DATA64 structure is encrypted. I checked the 1st page.</p>

<p><img src="http://TakahiroHaruyama.github.io/images/post/NumberOfRuns.jpg" alt="1st_header" /></p>

<p>In a crashdump acquired by winpmem, NumberOfRuns of _PHYSICAL_MEMORY_DESCRIPTOR64 includes &ldquo;PAGE&rdquo; (this value should be defined as qword, correct?). That&rsquo;s why the script fails in parsing the structure. I modified NumberOfRuns then could get the analysis result.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Some Old Stuffs]]></title>
    <link href="http://TakahiroHaruyama.github.io/blog/2014/01/05/some-old-stuffs/"/>
    <updated>2014-01-05T23:37:20+09:00</updated>
    <id>http://TakahiroHaruyama.github.io/blog/2014/01/05/some-old-stuffs</id>
    <content type="html"><![CDATA[<h3>IOCs for memory forensics</h3>

<p>Never forget to configure &ldquo;advanced parameters&rdquo; (check String and the length is 4)</p>

<ul>
<li><a href="http://TakahiroHaruyama.github.io/downloads/IOCs/23592725-e7cb-4391-9148-2ce25b1ed00d.ioc">ZeroAccess</a> for kernel/user-mode variants</li>
<li><a href="http://TakahiroHaruyama.github.io/downloads/IOCs/66132886-d06c-4612-b51d-031a1c9fbc30.ioc">Poison Ivy</a></li>
<li><a href="http://TakahiroHaruyama.github.io/downloads/IOCs/c229d84e-3981-4c71-a16f-aa6a17b22c75.ioc">Zeus 2.x variants</a> including Citadel</li>
<li><a href="http://TakahiroHaruyama.github.io/downloads/IOCs/42392189-6ef8-4869-bb2e-b457c3e05ba1.ioc">SpyEye 1.3.x</a></li>
</ul>


<h3>IDAPython script</h3>

<ul>
<li><a href="http://TakahiroHaruyama.github.io/downloads/scripts/Deobfuscating_SpyEye.zip">Deobfuscating_SpyEye</a> deobfuscate 4-byte hash values and strings</li>
<li><a href="http://TakahiroHaruyama.github.io/downloads/scripts/zeus_string_decoder.py">zeus_string_decoder</a> decode strings in ZeuS binary</li>
<li><a href="http://TakahiroHaruyama.github.io/downloads/scripts/fix_junk_pony.py">fix_junk_pony</a> modify PONY&rsquo;s junk code</li>
</ul>


<h3>Immunity Debugger script</h3>

<ul>
<li><a href="http://TakahiroHaruyama.github.io/downloads/scripts/immbone_nx.zip">immbone_nx</a> break on execute script on DEP environment (enable DEP and uncheck the option ignoring Memory access violation in the debugger settings)</li>
<li><a href="http://TakahiroHaruyama.github.io/downloads/scripts/immbone.zip">immbone</a> break on execute script on non-DEP environment (disable DEP and uncheck the option ignoring single-step break in the debugger settings)</li>
<li><a href="http://TakahiroHaruyama.github.io/downloads/scripts/blackmanta.py">blackmanta</a> slightly-changed version for Immunity Debugger v1.8</li>
</ul>


<h3>EnCase EnScript</h3>

<ul>
<li><a href="http://TakahiroHaruyama.github.io/downloads/scripts/CrashDumpAnalyzer_20110322.zip">CrashDumpAnalyzer</a> memory forensic EnScripts for MS crash dump</li>
<li><a href="http://TakahiroHaruyama.github.io/downloads/scripts/RawImageAnalyzer_20110322.zip">RawImageAnalyzer</a> memory forensic EnScripts for raw memory dump</li>
<li><a href="http://TakahiroHaruyama.github.io/downloads/scripts/Timeline_Report_v1.8.1_CCI_20120511.zip">Timeline_Report_v1.8.1_CCI</a> NTFS SI/FN timeline EnScript based on Geoff Black&rsquo;s timeline EnScript</li>
<li><a href="http://TakahiroHaruyama.github.io/downloads/scripts/PFDCforPE.EnScript">PFDCforPE</a> parse/filter/detect/carve PE files</li>
</ul>


<h3>Others</h3>

<ul>
<li><a href="http://TakahiroHaruyama.github.io/downloads/scripts/amf_7x86.c">amf_7x86</a> PoC driver for anti memory forensics on Windows7</li>
<li><a href="http://TakahiroHaruyama.github.io/downloads/scripts/amf_XPx86.c">amf_XPx86</a> PoC driver for anti memory forensics on WindowsXP</li>
</ul>


<!-- * [](downloads/scripts/) -->

]]></content>
  </entry>
  
</feed>
