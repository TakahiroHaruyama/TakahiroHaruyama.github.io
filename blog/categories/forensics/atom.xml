<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: Forensics | CCI]]></title>
  <link href="http://TakahiroHaruyama.github.io/blog/categories/forensics/atom.xml" rel="self"/>
  <link href="http://TakahiroHaruyama.github.io/"/>
  <updated>2014-11-20T18:50:30+09:00</updated>
  <id>http://TakahiroHaruyama.github.io/</id>
  <author>
    <name><![CDATA[Takahiro Haruyama (@cci_forensics)]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[OpenIOC Parameters used by openioc_scan]]></title>
    <link href="http://TakahiroHaruyama.github.io/blog/2014/10/24/openioc-parameters-used-by-openioc-scan/"/>
    <updated>2014-10-24T18:09:24+09:00</updated>
    <id>http://TakahiroHaruyama.github.io/blog/2014/10/24/openioc-parameters-used-by-openioc-scan</id>
    <content type="html"><![CDATA[<p>&ldquo;Parameters&rdquo; introduced in OpenIOC 1.1 allows embedding additional metadata about Indicators into the IOC (in more detail, see <a href="https://media.blackhat.com/us-13/Arsenal/us-13-Gibb-IOCWriter_11-Slides.pdf">Blackhat 2013 presentation</a> by William Gibb). I implemented functions displaying matched content details and scoring results of indicator matching.</p>

<!-- more -->


<p>For using the new functions, you should define parameters in <a href="https://github.com/yahoo/PyIOCe">PyIOCe</a> written by Sean Gillespie. First, select [Modify Parameters] in Terms menu. Then add Context Type and Name/Value as below:</p>

<p><img src="/images/post/openioc_parameters/pyIOCe_param_define.JPG" alt="define" /></p>

<p>The Context Type should be lower-case because that of indicator items is &ldquo;volatility&rdquo;.</p>

<p>Next, double-click any terms and add parameters.</p>

<p><img src="/images/post/openioc_parameters/pyIOCe_param_add.JPG" alt="define" /></p>

<p>The value of &ldquo;detail&rdquo; should be &ldquo;on&rdquo;. And you can set any integer value between 0 to 100 for &ldquo;score&rdquo; value. Openioc_scan displays an IOC if the evaluation of all IOC terms/logics is true, or the total score of matched terms including &ldquo;score&rdquo; parameter is greater than or equal to &ldquo;SCORE_THRESHOLD&rdquo; (the default value is 100).</p>

<p>For instance, see the following result.</p>

<p><img src="/images/post/openioc_parameters/pyIOCe_param_result.JPG" alt="result" /></p>

<p>All indicator terms are combined with &ldquo;AND&rdquo; operator, but only 3 terms are matched, so the result without considering &ldquo;score&rdquo; parameter becomes False. However, openioc_scan says &ldquo;IOC matched&rdquo; because the total score is 100. We can check each score per term like &ldquo;(score=50;)&rdquo;. Similarly, we can refer to matched content detail for &ldquo;detail&rdquo; parameter by checking INFO logs above the IOC result.</p>

<p>In this way, OpenIOC parameters enable to define more-informational and flexible IOCs. I will implement more functions using parameters in the future.</p>

<h3>Download</h3>

<p>You can download the script and term/parameter definitions from <a href="http://takahiroharuyama.github.io/blog/2014/08/15/fast-malware-triage-using-openioc-scan-volatility-plugin/">here</a></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Fast Malware Triage using openioc_scan Volatility Plugin]]></title>
    <link href="http://TakahiroHaruyama.github.io/blog/2014/08/15/fast-malware-triage-using-openioc-scan-volatility-plugin/"/>
    <updated>2014-08-15T15:36:26+09:00</updated>
    <id>http://TakahiroHaruyama.github.io/blog/2014/08/15/fast-malware-triage-using-openioc-scan-volatility-plugin</id>
    <content type="html"><![CDATA[<p>Last year, I proposed &ldquo;volatile Indicators of Compromise (IOCs)&rdquo; based on RAM evidence only at <a href="http://digital-forensics.sans.org/summit-archives/DFIR_Summit/Volatile-IOCs-for-Fast-Incident-Response-Haruyama.pdf">SANS DFIR Summit</a>. We can detect malware using them faster than using disk-evidence-based IOCs. Besides, we can define indicators based on not only metadata (e.g., file path) but also malware function (e.g., code injection sign, imported functions and unpacked codes). The IOCs are described according to <a href="http://www.openioc.org/">OpenIOC</a> specification. <a href="http://www.mandiant.com/resources/download/ioc-editor/">IOC Editor</a> is used for defining IOCs and <a href="https://www.mandiant.com/resources/download/redline">Redline</a> is used for scannning IOCs.</p>

<p>Since then, I continued to make volatile IOCs and detect malware through the tools, but I&rsquo;ve got some frustrating problems about them. First, We can&rsquo;t automate IOC scanning for daily task because Redline is a GUI tool. Second, Redline is compliant with OpenIOC 1.0 but the spec doesn&rsquo;t support regular expression, case sensitiveness. In addition, &ldquo;AND&rdquo; combination of different items (e.g., ProcessItem and DriverItem) does not work. Furthermore, Redline cannot scan unallocated objects (e.g., dead process, unloaded kernel drivers). So I decied to make a new tool for volatile IOCs.</p>

<!-- more -->


<h3>openioc_scan Volatility plugin</h3>

<p>I wrote a plugin called &ldquo;openioc_scan&rdquo; for <a href="https://code.google.com/p/volatility/">Volatility Framework</a> that is a open-source memory forensic tool. The plugin supports only Windows Vista or later Windows versions (Linux and Mac OS X are not supported).</p>

<p>To run this plugin, you need to install the following Python modules.</p>

<ul>
<li><a href="https://pypi.python.org/pypi/lxml/3.2.1">lxml</a></li>
<li><a href="https://github.com/mandiant/ioc_writer">ioc_writer</a></li>
<li><a href="https://pypi.python.org/pypi/colorama">colorama</a></li>
</ul>


<p>We also must prepare IOCs for openioc_scan. Openioc_scan accepts only <a href="https://github.com/mandiant/OpenIOC_1.1">OpenIOC 1.1</a> XML files. We can define grep pattern (using &ldquo;matches&rdquo; condition) and case sensitiveness in the version. But unfortunately, Mandiant doesn&rsquo;t provide IOC Editor for the latest version yet. <del>I hope they will publish the updated one. Currently, we should generate IOCs on IOC Editor then convert them into new ones using openioc_10_to_11.py in ioc_writer.</del> <strong>(2014/8/25)</strong> Sean Gillespie distributes open-source IOC editor, <a href="https://github.com/yahoo/PyIOCe">PyIOCe</a>. We can generate OpenIOC 1.1 indicator files using it.</p>

<p>Openioc_scan has several options.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>-p PID, &mdash;pid=PID     Operate on these Process IDs (comma-separated)
</span><span class='line'>  -i IOC_DIR, &mdash;ioc_dir=IOC_DIR&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>                    Location of IOCs directory
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>  -s, &mdash;show            Display IOC definition only
</span><span class='line'>  -c CACHE_PATH, &mdash;cache_path=CACHE_PATH&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>                    Specify the cache folder path of analysis result
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p>  -m KMOD, &mdash;kmod=KMOD  Operate on these kernel module names (comma-separated,&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>                    case-insensitive)
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>&ldquo;&mdash;show&rdquo; option just shows the IOCs included in the directory specified by &ldquo;&mdash;ioc_dir&rdquo; option.</p>

<p><img src="/images/post/openioc_scan/show.jpg" alt="show" /></p>

<p>If we run openioc_scan without -s option, the plugin scans the specified memory image using IOCs then display the result.</p>

<p><img src="/images/post/openioc_scan/scan.jpg" alt="scan" /></p>

<p>Openioc_scan generates a cache database for result because some IOC items to scan may take long time. If there are no records about items in cache, openioc_scan outputs &ldquo;[time-consuming task]&rdquo; logs during the scan. Once a cache corresponding to defined items is generated, we can scan the same items rapidly.</p>

<p>For instance, the first run took 2327 secs:</p>

<p><img src="/images/post/openioc_scan/1st_run.jpg" alt="1st_run" /></p>

<p>The second run or later took only 149 secs because of cache db extracted by the 1st run:</p>

<p><img src="/images/post/openioc_scan/2nd_run.jpg" alt="2nd_run" /></p>

<h3>Supported Terms (2014/11/14)</h3>

<p>I show 34 terms supported by openioc_scan. <del>To make maximal use of openioc_scan, we had better newly add some term definitions in Configuration\IOCTerms*.iocterms file of IOC Editor installed folder (for more detail, see IOCe user guide). </del>  <del><strong>(2014/8/25)</strong> We can add new definitions on PyIOCe from Terms->Indicator Terms menu as follows:</del> <strong>(2014/9/30)</strong> Sean added term import/export functions to PyIOCe. You can import <a href="/downloads/scripts/indicator_terms.volatility">the terms for Volatility</a> or PyIOCe with all Volatility terms may be released shortly. Thanks Sean!</p>

<p><img src="/images/post/openioc_scan/new_terms.jpg" alt="new_terms" /></p>

<h4>ProcessItem (17 Terms)</h4>

<ul>
<li><strong>ProcessItem/name (string)</strong> &hellip; process name (max 15 characters)</li>
<li><strong>ProcessItem/ParentProcessName (string)</strong> &hellip; process name of the parent process</li>
<li><strong>ProcessItem/path (string)</strong> &hellip; path in the command line of process</li>
<li><strong>ProcessItem/DllPath (string)</strong> &hellip; dll path loaded in process (base on <em>ldrmodules</em> command)</li>
<li><strong>ProcessItem/arguments (string)</strong> &hellip; command line arguments</li>
<li><strong>ProcessItem/hidden (bool, should be &ldquo;true&rdquo; or &ldquo;false&rdquo;)</strong> &hellip; process hidden by rootkit (e.g., DKOM). This item is based on part of <em>psxview</em> command, but dead process with exit time is excluded before evaluation.</li>
<li><strong>ProcessItem/SectionList/MemorySection/Injected (bool)</strong> &hellip; process with potential section of injected or unpacked code based on <em>malfind</em> command</li>
<li><strong>ProcessItem/StringList/string (string)</strong> &hellip; strings or binary code sequences in the process</li>
<li><strong>ProcessItem/SectionList/MemorySection/PEInfo/ImportedModules/Module/ImportedFunctions/string (string)</strong> &hellip; imported function names based on <em>impscan</em>. The original command scans only base+SizeOfImage, so I added code injected section as scan target. This item doesn&rsquo;t work on wow64 process due to impscan&rsquo;s limitation.</li>
<li><strong>ProcessItem/HandleList/Handle/Name (string), ProcessItem/HandleList/Handle/Type (string)</strong> &hellip; process handle information based on <em>handles</em> command</li>
<li><strong>ProcessItem/PortList/PortItem/localPort (integer), ProcessItem/PortList/PortItem/remotePort (integer), ProcessItem/PortList/PortItem/localIP (string), ProcessItem/PortList/PortItem/remoteIP (string)</strong> &hellip; network information related to the process from the result of <em>netscan</em> command</li>
<li><strong>ProcessItem/Hooked/API/FunctionName (string)</strong> &hellip; IAT/EAT/Inline hooked API function name based on <em>apihooks</em> command</li>
<li><strong>ProcessItem/EnabledPrivilege/Name (string)</strong> &hellip; explicitly enabled privilege name extracted from <em>privs</em> command (e.g., SeDebugPrivilege)</li>
</ul>


<h4>RegistryItem (2 Terms)</h4>

<ul>
<li><strong>RegistryItem/Path (string)</strong> &hellip; registry key or value paths based on <em>hivelist&amp;printkey</em>. It&rsquo;s too slow, so I recommend to use handle names instead. For example, it takes 12 hours in 512MB RAM :&ndash;(</li>
<li><strong>RegistryItem/ShimCache/ExecutablePath (string)</strong> &hellip; exe/dll/bat file paths included in <em>shimcache</em> artifact</li>
</ul>


<h4>ServiceItem (3 Terms)</h4>

<ul>
<li><strong>ServiceItem/name (string)</strong> &hellip; service name</li>
<li><strong>ServiceItem/descriptiveName (string)</strong> &hellip; service description name</li>
<li><strong>ServiceItem/cmdLine (string)</strong> &hellip; command line of the service</li>
</ul>


<h4>DriverItem (6 Terms)</h4>

<ul>
<li><strong>DriverItem/DriverName (string)</strong> &hellip; kernel driver name extracted from <em>lsmod</em> method (to be improved in the future)</li>
<li><strong>DriverItem/PEInfo/ImportedModules/Module/ImportedFunctions/string (string)</strong> &hellip; imported function names based on <em>impscan</em></li>
<li><strong>DriverItem/StringList/string (string)</strong> &hellip; strings or binary code sequences in the driver</li>
<li><strong>DriverItem/IRP/HookingModuleName (string)</strong> &hellip; kernel module name hooking IRP major function table (e.g., rootkit hooking IRP_MJ_DEVICE_CONTROL in tcpip.sys), based on <em>driverirp</em> command</li>
<li><strong>DriverItem/CallbackRoutine/Type (string)</strong> &hellip; kernel callback function type from <em>callbacks</em> command</li>
<li><strong>DriverItem/TimerRoutineIncluded (bool)</strong> &hellip; the kernel module includes kernel timer functions or not</li>
</ul>


<h4>HookItem (1 Term)</h4>

<ul>
<li><strong>HookItem/SSDT/HookedFunctionName (string)</strong> &hellip; hooked system call function name in SSDT (e.g., NtQueryDirectoryFile)</li>
</ul>


<h4>FileItem (5 Terms)</h4>

<ul>
<li><strong> FileItem/FileName (string)</strong> &hellip; file name extracted by <em>mftparser</em></li>
<li><strong> FileItem/FileExtension (string)</strong> &hellip; file extension extracted by <em>mftparser</em></li>
<li><strong> FileItem/INode (integer)</strong> &hellip; MFT entry number extracted by <em>mftparser</em></li>
<li><strong> FileItem/FullPath (string)</strong> &hellip; file path extracted by <em>mftparser</em></li>
<li><strong> FileItem/SizeInBytes (integer)</strong> &hellip; file size extracted by <em>mftparser</em></li>
</ul>


<h3>Examples</h3>

<p>Using openioc_scan, we can detect malware based on our own rules. I show some examples for detecting PlugX type II/III and WebInject malware. About PlugX, see this <a href="https://www.blackhat.com/docs/asia-14/materials/Haruyama/Asia-14-Haruyama-I-Know-You-Want-Me-Unplugging-PlugX.pdf">presentation</a>. Actually, all IOCs are generic indicators, so they can be applied to other malware.</p>

<p>rogue svchost:</p>

<p><img src="/images/post/openioc_scan/ex_svchost.jpg" alt="examples1" /></p>

<p>unusual executable paths:</p>

<p><img src="/images/post/openioc_scan/ex_iron.jpg" alt="examples2" /></p>

<p>malware bypassing UAC pop-up:</p>

<p><img src="/images/post/openioc_scan/ex_uac.jpg" alt="examples3" /></p>

<p>WebInject malware (e.g., ZeuS and its variants):</p>

<p><img src="/images/post/openioc_scan/webinject.jpg" alt="examples4" /></p>

<h3>Future Work</h3>

<p>I will support <del>dead process</del> / unloaded  or hidden driver terms in the future. <del>I will also consider the term about auto-startup entries (e.g., registry Run keys) extracted from RAM.</del> <del>Scoring function using OpenIOC parameters may be implemented.</del></p>

<p>Any comments or feedback are welcome.</p>

<h3>Download (latest:2014/11/14)</h3>

<p><a href="/downloads/scripts/openioc_scan.py">openioc_scan.py</a></p>

<p>You can use it by just copying it into volatility\plugins\malware folder. I checked it worked on Volatility 2.4 and 2.3.1.</p>

<p>And example IOCs:</p>

<ul>
<li><a href="/downloads/IOCs/v11/a50223b5-b213-43e9-beac-dfe9c1ca240c_rogue_svchost.ioc">rogue svchost</a></li>
<li><a href="/downloads/IOCs/v11/7382c170-7e66-4d72-808e-5f703f39a38d_unusual_path.ioc">suspicious exec path</a></li>
<li><a href="/downloads/IOCs/v11/cdcd5fdb-fcd3-4947-8c76-d2fbdc1b5f82_UAC.ioc">UAC pop-up bypassing</a></li>
<li><a href="/downloads/IOCs/v11/2823537b-8c9a-454a-8bf4-3aa5ef76ec54_webinject.ioc">WebInject malware</a></li>
</ul>


<p>Last but not least, here are <a href="/downloads/scripts/indicator_terms.volatility">terms</a> and <a href="/downloads/scripts/parameters.volatility">parameters</a> of Volatility used in PyIOCe.</p>

<p>Let me know if you have any question or problem. Enjoy ;&ndash;)</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Memory Forensics: still aborted]]></title>
    <link href="http://TakahiroHaruyama.github.io/blog/2014/04/21/memory-forensics-still-aborted/"/>
    <updated>2014-04-21T19:34:48+09:00</updated>
    <id>http://TakahiroHaruyama.github.io/blog/2014/04/21/memory-forensics-still-aborted</id>
    <content type="html"><![CDATA[<p>2 years ago, I talked about the anti memory forensic method by modifying Windows kernel data structure on victim systems at <a href="http://www.blackhat.com/html/bh-eu-12/bh-eu-12-archives.html#haruyama">BlackHat Europe 2012</a>. The situation is still the same.</p>

<!-- more -->


<h3>Abort Factors and PoC Driver</h3>

<p>In the past presentation, I showed &ldquo;Abort Factors&rdquo;, they are key structures for virtual address translation, guessing OS version and listing kernel objects. Once they are modified, memory analysis tools cannot continue to analyze images.</p>

<p><img src="/images/post/amf/AbortFactors.jpg" alt="AbortFactors" /></p>

<p>Today, I re-evaluated memory analysis tools: Volatility Framework 2.3.1 and Mandiant Redline 1.11.1
(now no one uses HBGary Responder, right?). I loaded the PoC driver modifying abort factors again then acquired the RAM. Unfortunately, the results were the same as those two years ago. I could not extract any information from the image.</p>

<p><img src="/images/post/amf/aborted_volatility.jpg" alt="abort_vol" /></p>

<p><img src="/images/post/amf/aborted_redline.jpg" alt="abort_red" /></p>

<h3>Countermeasures</h3>

<p>As I explained in the slides, the countermeasures are simple.</p>

<p>The tools should keep their guessings at a minimum. For instance, support a crash dump format. A crash dump includes CR3 register value, so tools need not guess kernel DTB (Directory Table Base). If CR3 value is modified, BSOD always occurs. Besides, allow users to specify OS versions.
Volatility Framework already support the options. In that sense, Volatility is better than Redline.</p>

<p>On the other hand, Redline (Memoryze) is better than Volatility in terms of the kernel object listing (e.g., pslist command) because it doesn&rsquo;t depend on debug data structure like _DBGKD_DEBUG_DATA_HEADER64. However, Volatility users can use psscan instead of pslist. Therefore, it may be nothing more than a trivial risk.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[64bit big sized RAM Image Acquisition Problem]]></title>
    <link href="http://TakahiroHaruyama.github.io/blog/2014/01/07/64bit-big-size-ram-acquisition-problem/"/>
    <updated>2014-01-07T22:15:39+09:00</updated>
    <id>http://TakahiroHaruyama.github.io/blog/2014/01/07/64bit-big-size-ram-acquisition-problem</id>
    <content type="html"><![CDATA[<h3>The Problem</h3>

<p>One day, I acquired a 16GB raw memory image on Windows7 x64 machine using MoonSols DumpIt for malware investigation. Then I tried to analyze it using Volatility Framework and Redline, but they returned no output like this:</p>

<p><img src="/images/post/vol_no_result.jpg" alt="vol_no_result" /></p>

<p>I guessed the acquired image was corrupted, so I took an image again, but the result was the same. I googled about the problem and found <a href="https://code.google.com/p/volatility/issues/detail?id=412">a similar issue</a>. According to the report, I tested several memory acquisition tools such as FTK Imager and Windows Memory Reader, but they didn&rsquo;t work.</p>

<p>I changed an image format from raw to crashdump. Then Volatility Framework could parse it and display the result. Strangely, Volatility also could analyze the raw image converted from the crashdump. Where does this difference come from?</p>

<!-- more -->


<h3>The Cause</h3>

<p>I debugged Volatility and noticed it could not find _KDDEBUGGER_DATA64 structure.</p>

<p><div class='bogus-wrapper'><notextile><figure class='code'><div class="highlight"><table><tr><td class="gutter"><pre class="line-numbers"><span class='line-number'>1</span>
<span class='line-number'>2</span>
<span class='line-number'>3</span>
<span class='line-number'>4</span>
<span class='line-number'>5</span>
<span class='line-number'>6</span>
<span class='line-number'>7</span>
<span class='line-number'>8</span>
<span class='line-number'>9</span>
<span class='line-number'>10</span>
<span class='line-number'>11</span>
<span class='line-number'>12</span>
<span class='line-number'>13</span>
<span class='line-number'>14</span>
<span class='line-number'>15</span>
<span class='line-number'>16</span>
<span class='line-number'>17</span>
<span class='line-number'>18</span>
<span class='line-number'>19</span>
<span class='line-number'>20</span>
<span class='line-number'>21</span>
<span class='line-number'>22</span>
<span class='line-number'>23</span>
<span class='line-number'>24</span>
<span class='line-number'>25</span>
<span class='line-number'>26</span>
<span class='line-number'>27</span>
<span class='line-number'>28</span>
<span class='line-number'>29</span>
<span class='line-number'>30</span>
<span class='line-number'>31</span>
<span class='line-number'>32</span>
<span class='line-number'>33</span>
<span class='line-number'>34</span>
<span class='line-number'>35</span>
<span class='line-number'>36</span>
<span class='line-number'>37</span>
<span class='line-number'>38</span>
<span class='line-number'>39</span>
</pre></td><td class='code'><pre><code class=''><span class='line'>&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;p>def get_kdbg(addr_space):&lt;/p>
</span><span class='line'>
</span><span class='line'>&lt;pre>&lt;code>"""A function designed to return the KDBG structure from 
</span><span class='line'>an address space. First we try scanning for KDBG and if 
</span><span class='line'>that fails, we try scanning for KPCR and bouncing back to
</span><span class='line'>KDBG from there. 
</span><span class='line'>
</span><span class='line'>Also note, both the primary and backup methods rely on the 
</span><span class='line'>4-byte KDBG.Header.OwnerTag. If someone overwrites this 
</span><span class='line'>value, then neither method will succeed. The same is true 
</span><span class='line'>even if a user specifies --kdbg, because we check for the 
</span><span class='line'>OwnerTag even in that case. 
</span><span class='line'>"""
</span><span class='line'>
</span><span class='line'>kdbgo = obj.VolMagic(addr_space).KDBG.v()
</span><span class='line'>
</span><span class='line'>kdbg = obj.Object("\_KDDEBUGGER_DATA64", offset = kdbgo, vm = addr_space) 
</span><span class='line'>
</span><span class='line'>if kdbg.is_valid(): # &lt;- failed
</span><span class='line'>    return kdbg
</span><span class='line'>
</span><span class='line'># Fall back to finding it via the KPCR. We cannot
</span><span class='line'># accept the first/best suggestion, because only 
</span><span class='line'># the KPCR for the first CPU allows us to find KDBG. 
</span><span class='line'>for kpcr_off in obj.VolMagic(addr_space).KPCR.generate_suggestions():
</span><span class='line'>
</span><span class='line'>    kpcr = obj.Object("_KPCR", offset = kpcr_off, vm = addr_space)
</span><span class='line'>
</span><span class='line'>    kdbg = kpcr.get_kdbg() 
</span><span class='line'>
</span><span class='line'>    if kdbg.is_valid(): # &lt;- failed
</span><span class='line'>        return kdbg
</span><span class='line'>
</span><span class='line'>return obj.NoneObject("KDDEBUGGER structure not found using either KDBG signature or KPCR pointer")
</span><span class='line'>&lt;/code>&lt;/pre>
</span><span class='line'>
</span><span class='line'>&lt;p></span></code></pre></td></tr></table></div></figure></notextile></div></p>

<p>_KDDEBUGGER_DATA64 includes various debug information like PsLoadedModuleList. Matthieu Suiche at MoonSols told me Vista or later Windows OSes on x64 machines encrypt the structure. So I compared a simply-dumped raw image with a raw image converted from crashdump.</p>

<p><img src="/images/post/DBGKD_DEBUG_DATA_HEADER64.jpg" alt="kdbg_encrypted" /></p>

<p>DBGKD_DEBUG_DATA_HEADER64 in _KDDEBUGGER_DATA64 is highlighted. Surely, it seems to be encoded by a specific algorithm. I think there is a few people knowing the fact because <strong>the encryption is only applied to big size RAM</strong> (if not correct, please let me know). For instance, I checked _KDDEBUGGER_DATA64 in 1GB raw image was not encrypted and analysis tools worked fine.</p>

<h3>Which acquisition tools should we use?</h3>

<p>Matthieu said DumpIt implemented the decryption of _KDDEBUGGER_DATA64 structure for crashdump format only. I investigated whether acquisition tools including DumpIt can decrypt the structure. I showed the result in the folowing table.</p>

<p><img src="/images/post/acquisition_tools_result.png" alt="acquisition_tools_result" /></p>

<p>The result means the only option is to take crashdump using DumpIt. Any other tools don&rsquo;t decrypt. So, why DumpIt can decrypt the structure? I reverse-engineered the driver code and found it used KdSystemDebugControl to get _DBGKD_GET_VERSION64 and _KDDEBUGGER_DATA64, then made its crashdump header (1st page in .dmp) manually by inserting _KDDEBUGGER_DATA64 member values, but I couldn&rsquo;t find the decryption routine by static code analysis. The local debugging API is related to the decryption? not sure.</p>

<p><img src="/images/post/KdSystemDebugControl.jpg" alt="KdSystemDebugControl" /></p>

<h3>Just for the record,</h3>

<p>64-bit crashdump images generated by Windows Memory Reader and winpmem couldn&rsquo;t be analyzed by my EnScript, CrashDumpAnalyzer. I cannot understand the error because my EnScript reads debug information from the 1st header, so the EnScript is due to parse it even if _KDDEBUGGER_DATA64 structure is encrypted. I checked the 1st page.</p>

<p><img src="/images/post/NumberOfRuns.jpg" alt="1st_header" /></p>

<p>In a crashdump acquired by winpmem, NumberOfRuns of _PHYSICAL_MEMORY_DESCRIPTOR64 includes &ldquo;PAGE&rdquo; (this value should be defined as qword, correct?). That&rsquo;s why the script fails in parsing the structure. I modified NumberOfRuns then could get the analysis result.</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Some Old Stuffs]]></title>
    <link href="http://TakahiroHaruyama.github.io/blog/2014/01/05/some-old-stuffs/"/>
    <updated>2014-01-05T23:37:20+09:00</updated>
    <id>http://TakahiroHaruyama.github.io/blog/2014/01/05/some-old-stuffs</id>
    <content type="html"><![CDATA[<h3>IOCs for memory forensics</h3>

<p>Never forget to configure &ldquo;advanced parameters&rdquo; (check String and the length is 4)</p>

<ul>
<li><a href="/downloads/IOCs/23592725-e7cb-4391-9148-2ce25b1ed00d.ioc">ZeroAccess</a> for kernel/user-mode variants</li>
<li><a href="/downloads/IOCs/66132886-d06c-4612-b51d-031a1c9fbc30.ioc">Poison Ivy</a></li>
<li><a href="/downloads/IOCs/c229d84e-3981-4c71-a16f-aa6a17b22c75.ioc">Zeus 2.x variants</a> including Citadel</li>
<li><a href="/downloads/IOCs/42392189-6ef8-4869-bb2e-b457c3e05ba1.ioc">SpyEye 1.3.x</a></li>
</ul>


<h3>IDAPython script</h3>

<ul>
<li><a href="/downloads/scripts/Deobfuscating_SpyEye.zip">Deobfuscating_SpyEye</a> deobfuscate 4-byte hash values and strings</li>
<li><a href="/downloads/scripts/zeus_string_decoder.py">zeus_string_decoder</a> decode strings in ZeuS binary</li>
<li><a href="/downloads/scripts/fix_junk_pony.py">fix_junk_pony</a> modify PONY&rsquo;s junk code</li>
</ul>


<h3>Immunity Debugger script</h3>

<ul>
<li><a href="/downloads/scripts/immbone_nx.zip">immbone_nx</a> break on execute script on DEP environment (enable DEP and uncheck the option ignoring Memory access violation in the debugger settings)</li>
<li><a href="/downloads/scripts/immbone.zip">immbone</a> break on execute script on non-DEP environment (disable DEP and uncheck the option ignoring single-step break in the debugger settings)</li>
<li><a href="/downloads/scripts/blackmanta.py">blackmanta</a> slightly-changed version for Immunity Debugger v1.8</li>
</ul>


<h3>EnCase EnScript</h3>

<ul>
<li><a href="/downloads/scripts/CrashDumpAnalyzer_20110322.zip">CrashDumpAnalyzer</a> memory forensic EnScripts for MS crash dump</li>
<li><a href="/downloads/scripts/RawImageAnalyzer_20110322.zip">RawImageAnalyzer</a> memory forensic EnScripts for raw memory dump</li>
<li><a href="/downloads/scripts/Timeline_Report_v1.8.1_CCI_20120511.zip">Timeline_Report_v1.8.1_CCI</a> NTFS SI/FN timeline EnScript based on Geoff Black&rsquo;s timeline EnScript</li>
<li><a href="/downloads/scripts/PFDCforPE.EnScript">PFDCforPE</a> parse/filter/detect/carve PE files</li>
</ul>


<h3>Others</h3>

<ul>
<li><a href="/downloads/scripts/amf_7x86.c">amf_7x86</a> PoC driver for anti memory forensics on Windows7</li>
<li><a href="/downloads/scripts/amf_XPx86.c">amf_XPx86</a> PoC driver for anti memory forensics on WindowsXP</li>
</ul>


<!-- * [](downloads/scripts/) -->

]]></content>
  </entry>
  
</feed>
