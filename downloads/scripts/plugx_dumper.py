# plugx_dumper.py - Immunity Debugger script dumping/parsing PlugX encrypted config and PE in infected process
# Copyright (c) 2014 Takahiro Haruyama
# Type I decryption algorithm is based on plugxdecoder (https://github.com/kcreyts/plugxdecoder)
#
# This script can be used for PlugX specimens including config whose size is 0x150C/0x1510/0x1B18/0x1D18/0x2540/0x7AC#2
# How to use:
# 1. Run PlugX specimen
# 2. Attach to a process generated by the specimen (e.g., svchost/msiexec/iexplore/winlogon) using Immunity Debugger
# 3. Run this script located in PyCommands (!plugx_dumper)
# 4. Check the result in Log view
# For more detail, check this blog post: http://takahiroharuyama.github.io/

import immlib
import sys, math
from struct import *
from ctypes import *
imm = immlib.Debugger()

save_path = "PyCommands\\"
signature = "GULP"

nt = windll.ntdll

def H(data):
    if not data:
        return 0

    entropy = 0
    for x in range(256):
        p_x = float(data.count(chr(x)))/len(data)
        if p_x > 0:
            entropy += - p_x*math.log(p_x,2)
    return entropy

def getASCII(wString):
    asciiString = ""
    i = 0
    while( i < len(wString)):
        asciiString+=wString[i]
        i+=2
    return asciiString

def print_config(out):
    imm.log(out)
    return (out+'\n')

def parse_ver4_config(xsetting):
    num_of_servers = 4
    C2_struct_len = 68
    C2Setting_url_len = 128
    proxy_struct_len = 196

    result = print_config("PlugX config (0x1D18)")
    # C2 servers
    for C2_entry in range(num_of_servers):
        entry_offset = 0x2EC + C2_entry * C2_struct_len
        protocol_flag, port, hostname = unpack("<HH64s", xsetting[entry_offset:entry_offset+C2_struct_len])
        hostname = hostname.decode('ascii').split('\0')[0]
        result += print_config("C2 server entry %d: protocol flag (TCP:1,HTTP:2,UDP:4,ICMP:8) = %d, hostname = %s, port = %d" % (C2_entry, protocol_flag, hostname, port))

    # C2Setting URLs
    for C2S_entry in range(num_of_servers):
        entry_offset = 0x3FC + C2S_entry * C2Setting_url_len
        url = unpack("128s", xsetting[entry_offset:entry_offset+C2Setting_url_len])[0]
        url = url.decode('ascii').split('\0')[0]
        result += print_config("C2Setting URL entry %d: URL = %s" % (C2S_entry, url))

    # Proxy Settings
    for proxy_entry in range(num_of_servers):
        entry_offset = 0x5FC + proxy_entry * proxy_struct_len
        proxy_type, proxy_port, proxy_hostname, proxy_username, proxy_password = unpack("<HH64s64s64s", xsetting[entry_offset:entry_offset+proxy_struct_len])
        proxy_hostname = proxy_hostname.decode('ascii').split('\0')[0]
        proxy_username = proxy_username.decode('ascii').split('\0')[0]
        proxy_password = proxy_password.decode('ascii').split('\0')[0]
        result += print_config("proxy server entry %d: proxy type (0:none,1:TCP,2:TCPwithAuth?,3:HTTP) = %d, hostname = %s, port = %d, username = %s, password = %s" % (proxy_entry, proxy_type, proxy_hostname, proxy_port, proxy_username, proxy_password))

    # install option
    option = unpack("<I", xsetting[0x90C:0x910])[0]
    result += print_config("install option (0=service,1=registry,2=already_registered_by_loader): %d" % (option))

    # install information
    folder = unpack("512s", xsetting[0x910:0xB10])[0]
    folder = folder.decode('utf-16le').split('\0')[0]
    result += print_config("install folder path: %s" % (folder))

    service_name = unpack("512s", xsetting[0xB10:0xD10])[0]
    service_name = service_name.decode('utf-16le').split('\0')[0]
    result += print_config("service name: %s" % (service_name))

    display_name = unpack("512s", xsetting[0xD10:0xF10])[0]
    display_name = display_name.decode('utf-16le').split('\0')[0]
    result += print_config("service display name: %s" % (display_name))

    service_desc = unpack("512s", xsetting[0xF10:0x1110])[0]
    service_desc = service_desc.decode('utf-16le').split('\0')[0]
    result += print_config("service description: %s" % (service_desc))

    hive_type = unpack("<I", xsetting[0x1110:0x1114])[0]
    result += print_config("registry hive type(e.g., HKEY_CURRENT_USER=0x80000001): 0x%08X" % (hive_type))

    registry_key = unpack("512s", xsetting[0x1114:0x1314])[0]
    registry_key = registry_key.decode('utf-16le').split('\0')[0]
    result += print_config("registry key: %s" % (registry_key))

    registry_value = unpack("512s", xsetting[0x1314:0x1514])[0]
    registry_value = registry_value.decode('utf-16le').split('\0')[0]
    result += print_config("registry value: %s" % (registry_value))

    # stand alone flag
    is_stand_alone = unpack("<I", xsetting[0x1514:0x1518])[0]
    result += print_config("stand alone flag: %d" % (is_stand_alone))

    # injection target
    target = unpack("512s", xsetting[0x1518:0x1718])[0]
    target = target.decode('utf-16le').split('\0')[0]
    result += print_config("injection target: %s" % (target))
    target2 = unpack("512s", xsetting[0x1718:0x1918])[0]
    target2 = target2.decode('utf-16le').split('\0')[0]
    result += print_config("injection target2?: %s" % (target2))
    target3 = unpack("512s", xsetting[0x1918:0x1B18])[0]
    target3 = target3.decode('utf-16le').split('\0')[0]
    result += print_config("injection target3?: %s" % (target3))

    # mutex name in injected process (e.g., svchost)
    mutex = unpack("512s", xsetting[0x1B18:0x1D18])[0]
    mutex = mutex.decode('utf-16le').split('\0')[0]
    result += print_config("mutex name in injected process: %s" % (mutex))

    return result

def parse_1B18_config(xsetting):
    num_of_servers = 4
    C2_struct_len = 68
    C2Setting_url_len = 128

    result = print_config("PlugX config (0x1B18)")
    # C2 servers
    for C2_entry in range(num_of_servers):
        entry_offset = 0x2EC + C2_entry * C2_struct_len
        protocol_flag, port, hostname = unpack("<HH64s", xsetting[entry_offset:entry_offset+C2_struct_len])
        hostname = hostname.decode('ascii').split('\0')[0]
        result += print_config("C2 server entry %d: protocol flag (TCP:1,HTTP:2,UDP:4,ICMP:8) = %d, hostname = %s, port = %d" % (C2_entry, protocol_flag, hostname, port))

    # C2Setting URLs
    for C2S_entry in range(num_of_servers):
        entry_offset = 0x3FC + C2S_entry * C2Setting_url_len
        url = unpack("128s", xsetting[entry_offset:entry_offset+C2Setting_url_len])[0]
        url = url.decode('ascii').split('\0')[0]
        result += print_config("C2Setting URL entry %d: URL = %s" % (C2S_entry, url))

    # install option
    option = unpack("<I", xsetting[0x90C:0x910])[0]
    result += print_config("install option (0=service,1=registry,2=already_registered_by_loader): %d" % (option))

    # install information
    folder = unpack("512s", xsetting[0x910:0xB10])[0]
    folder = folder.decode('utf-16le').split('\0')[0]
    result += print_config("install folder path: %s" % (folder))

    service_name = unpack("512s", xsetting[0xB10:0xD10])[0]
    service_name = service_name.decode('utf-16le').split('\0')[0]
    result += print_config("service name: %s" % (service_name))

    display_name = unpack("512s", xsetting[0xD10:0xF10])[0]
    display_name = display_name.decode('utf-16le').split('\0')[0]
    result += print_config("service display name: %s" % (display_name))

    service_desc = unpack("512s", xsetting[0xF10:0x1110])[0]
    service_desc = service_desc.decode('utf-16le').split('\0')[0]
    result += print_config("service description: %s" % (service_desc))

    hive_type = unpack("<I", xsetting[0x1110:0x1114])[0]
    result += print_config("registry hive type(e.g., HKEY_CURRENT_USER=0x80000001): 0x%08X" % (hive_type))

    registry_key = unpack("512s", xsetting[0x1114:0x1314])[0]
    registry_key = registry_key.decode('utf-16le').split('\0')[0]
    result += print_config("registry key: %s" % (registry_key))

    registry_value = unpack("512s", xsetting[0x1314:0x1514])[0]
    registry_value = registry_value.decode('utf-16le').split('\0')[0]
    result += print_config("registry value: %s" % (registry_value))

    # stand alone flag
    is_stand_alone = unpack("<I", xsetting[0x1514:0x1518])[0]
    result += print_config("stand alone flag: %d" % (is_stand_alone))

    # injection target
    target = unpack("512s", xsetting[0x1518:0x1718])[0]
    target = target.decode('utf-16le').split('\0')[0]
    result += print_config("injection target: %s" % (target))
    target2 = unpack("512s", xsetting[0x1718:0x1918])[0]
    target2 = target2.decode('utf-16le').split('\0')[0]
    result += print_config("injection target2?: %s" % (target2))
    target3 = unpack("512s", xsetting[0x1918:0x1B18])[0]
    target3 = target3.decode('utf-16le').split('\0')[0]
    result += print_config("injection target3?: %s" % (target3))

    return result

def parse_150C_config(xsetting):
    num_of_servers = 4
    C2_struct_len = 68
    C2Setting_url_len = 128
    proxy_struct_len = 196

    result = print_config("PlugX config (0x150C)")
    # C2 servers
    for C2_entry in range(num_of_servers):
        entry_offset = 0x2EC + C2_entry * C2_struct_len
        protocol_flag, port, hostname = unpack("<HH64s", xsetting[entry_offset:entry_offset+C2_struct_len])
        hostname = hostname.decode('ascii').split('\0')[0]
        result += print_config("C2 server entry %d: protocol flag (TCP:1,HTTP:2,UDP:4,ICMP:8) = %d, hostname = %s, port = %d" % (C2_entry, protocol_flag, hostname, port))

    # C2Setting URLs
    for C2S_entry in range(num_of_servers):
        entry_offset = 0x3FC + C2S_entry * C2Setting_url_len
        url = unpack("128s", xsetting[entry_offset:entry_offset+C2Setting_url_len])[0]
        url = url.decode('ascii').split('\0')[0]
        result += print_config("C2Setting URL entry %d: URL = %s" % (C2S_entry, url))

    # Proxy Settings
    for proxy_entry in range(num_of_servers):
        entry_offset = 0x5FC + proxy_entry * proxy_struct_len
        proxy_type, proxy_port, proxy_hostname, proxy_username, proxy_password = unpack("<HH64s64s64s", xsetting[entry_offset:entry_offset+proxy_struct_len])
        proxy_hostname = proxy_hostname.decode('ascii').split('\0')[0]
        proxy_username = proxy_username.decode('ascii').split('\0')[0]
        proxy_password = proxy_password.decode('ascii').split('\0')[0]
        result += print_config("proxy server entry %d: proxy type (0:none,1:TCP,2:TCPwithAuth?,3:HTTP) = %d, hostname = %s, port = %d, username = %s, password = %s" % (proxy_entry, proxy_type, proxy_hostname, proxy_port, proxy_username, proxy_password))

    # install information
    folder = unpack("512s", xsetting[0x90C:0xB0C])[0]
    folder = folder.decode('utf-16le').split('\0')[0]
    result += print_config("install folder path: %s" % (folder))

    service_name = unpack("512s", xsetting[0xB0C:0xD0C])[0]
    service_name = service_name.decode('utf-16le').split('\0')[0]
    result += print_config("service name: %s" % (service_name))

    display_name = unpack("512s", xsetting[0xD0C:0xF0C])[0]
    display_name = display_name.decode('utf-16le').split('\0')[0]
    result += print_config("service display name: %s" % (display_name))

    service_desc = unpack("512s", xsetting[0xF0C:0x110C])[0]
    service_desc = service_desc.decode('utf-16le').split('\0')[0]
    result += print_config("service description: %s" % (service_desc))

    # injection target
    target2 = unpack("512s", xsetting[0x110C:0x130C])[0]
    target2 = target2.decode('utf-16le').split('\0')[0]
    result += print_config("injection target2?: %s" % (target2))
    target3 = unpack("512s", xsetting[0x130C:0x150C])[0]
    target3 = target3.decode('utf-16le').split('\0')[0]
    result += print_config("injection target3?: %s" % (target3))

    return result

def parse_1510_config(xsetting):
    num_of_servers = 4
    C2_struct_len = 68
    C2Setting_url_len = 128

    result = print_config("PlugX config (0x1510)")
    # C2 servers
    for C2_entry in range(num_of_servers):
        entry_offset = 0x2F0 + C2_entry * C2_struct_len
        protocol_flag, port, hostname = unpack("<HH64s", xsetting[entry_offset:entry_offset+C2_struct_len])
        hostname = hostname.decode('ascii').split('\0')[0]
        result += print_config("C2 server entry %d: protocol flag (TCP:1,HTTP:2,UDP:4,ICMP:8) = %d, hostname = %s, port = %d" % (C2_entry, protocol_flag, hostname, port))

    # C2Setting URLs
    for C2S_entry in range(num_of_servers):
        entry_offset = 0x400 + C2S_entry * C2Setting_url_len
        url = unpack("128s", xsetting[entry_offset:entry_offset+C2Setting_url_len])[0]
        url = url.decode('ascii').split('\0')[0]
        result += print_config("C2Setting URL entry %d: URL = %s" % (C2S_entry, url))

    # install information
    folder = unpack("512s", xsetting[0x910:0xB10])[0]
    folder = folder.decode('utf-16le').split('\0')[0]
    result += print_config("install folder path: %s" % (folder))

    service_name = unpack("512s", xsetting[0xB10:0xD10])[0]
    service_name = service_name.decode('utf-16le').split('\0')[0]
    result += print_config("service name: %s" % (service_name))

    display_name = unpack("512s", xsetting[0xD10:0xF10])[0]
    display_name = display_name.decode('utf-16le').split('\0')[0]
    result += print_config("service display name: %s" % (display_name))

    service_desc = unpack("512s", xsetting[0xF10:0x1110])[0]
    service_desc = service_desc.decode('utf-16le').split('\0')[0]
    result += print_config("service description: %s" % (service_desc))

    # injection target
    target2 = unpack("512s", xsetting[0x1110:0x1310])[0]
    target2 = target2.decode('utf-16le').split('\0')[0]
    result += print_config("injection target2?: %s" % (target2))
    target3 = unpack("512s", xsetting[0x1310:0x1510])[0]
    target3 = target3.decode('utf-16le').split('\0')[0]
    result += print_config("injection target3?: %s" % (target3))

    return result

def parse_2540_config(xsetting):
    num_of_servers = 4
    C2_struct_len = 68
    C2Setting_url_len = 128
    proxy_struct_len = 196

    result = print_config("PlugX config (0x2540)")
    # C2 servers
    for C2_entry in range(num_of_servers):
        entry_offset = 0x2EC + C2_entry * C2_struct_len
        protocol_flag, port, hostname = unpack("<HH64s", xsetting[entry_offset:entry_offset+C2_struct_len])
        hostname = hostname.decode('ascii').split('\0')[0]
        result += print_config("C2 server entry %d: protocol flag (TCP:1,HTTP:2,UDP:4,ICMP:8) = %d, hostname = %s, port = %d" % (C2_entry, protocol_flag, hostname, port))

    # C2Setting URLs
    for C2S_entry in range(num_of_servers):
        entry_offset = 0x3FC + C2S_entry * C2Setting_url_len
        url = unpack("128s", xsetting[entry_offset:entry_offset+C2Setting_url_len])[0]
        url = url.decode('ascii').split('\0')[0]
        result += print_config("C2Setting URL entry %d: URL = %s" % (C2S_entry, url))

    # Proxy Settings
    for proxy_entry in range(num_of_servers):
        entry_offset = 0x5FC + proxy_entry * proxy_struct_len
        proxy_type, proxy_port, proxy_hostname, proxy_username, proxy_password = unpack("<HH64s64s64s", xsetting[entry_offset:entry_offset+proxy_struct_len])
        proxy_hostname = proxy_hostname.decode('ascii').split('\0')[0]
        proxy_username = proxy_username.decode('ascii').split('\0')[0]
        proxy_password = proxy_password.decode('ascii').split('\0')[0]
        result += print_config("proxy server entry %d: proxy type (0:none,1:TCP,2:TCPwithAuth?,3:HTTP) = %d, hostname = %s, port = %d, username = %s, password = %s" % (proxy_entry, proxy_type, proxy_hostname, proxy_port, proxy_username, proxy_password))

    # install option
    option = unpack("<I", xsetting[0x90C:0x910])[0]
    result += print_config("install option (0or1=service,2=registry,3=already_registered_by_loader?): %d" % (option))

    # install information
    folder = unpack("512s", xsetting[0x910:0xB10])[0]
    folder = folder.decode('utf-16le').split('\0')[0]
    result += print_config("install folder path: %s" % (folder))

    service_name = unpack("512s", xsetting[0xB10:0xD10])[0]
    service_name = service_name.decode('utf-16le').split('\0')[0]
    result += print_config("service name: %s" % (service_name))

    display_name = unpack("512s", xsetting[0xD10:0xF10])[0]
    display_name = display_name.decode('utf-16le').split('\0')[0]
    result += print_config("service display name: %s" % (display_name))

    service_desc = unpack("512s", xsetting[0xF10:0x1110])[0]
    service_desc = service_desc.decode('utf-16le').split('\0')[0]
    result += print_config("service description: %s" % (service_desc))

    hive_type = unpack("<I", xsetting[0x1110:0x1114])[0]
    result += print_config("registry hive type(e.g., HKEY_CURRENT_USER=0x80000001): 0x%08X" % (hive_type))

    registry_key = unpack("512s", xsetting[0x1114:0x1314])[0]
    registry_key = registry_key.decode('utf-16le').split('\0')[0]
    result += print_config("registry key: %s" % (registry_key))

    registry_value = unpack("512s", xsetting[0x1314:0x1514])[0]
    registry_value = registry_value.decode('utf-16le').split('\0')[0]
    result += print_config("registry value: %s" % (registry_value))

    # stand alone flag
    #is_stand_alone = unpack("<I", xsetting[0x1514:0x1518])[0]
    #result += print_config("stand alone flag: %d" % (is_stand_alone))

    # injection target
    target = unpack("512s", xsetting[0x1518:0x1718])[0]
    target = target.decode('utf-16le').split('\0')[0]
    result += print_config("injection target: %s" % (target))
    target2 = unpack("512s", xsetting[0x1718:0x1918])[0]
    target2 = target2.decode('utf-16le').split('\0')[0]
    result += print_config("injection target2: %s" % (target2))
    target3 = unpack("512s", xsetting[0x1918:0x1B18])[0]
    target3 = target3.decode('utf-16le').split('\0')[0]
    result += print_config("injection target3: %s" % (target3))
    target4 = unpack("512s", xsetting[0x1B18:0x1D18])[0]
    target4 = target4.decode('utf-16le').split('\0')[0]
    result += print_config("injection target4: %s" % (target4))

    # magic word for C2 communication
    receive = unpack("512s", xsetting[0x1D18:0x1F18])[0]
    receive = receive.decode('utf-16le').split('\0')[0]
    result += print_config("receive magic word: %s" % (receive))
    send = unpack("512s", xsetting[0x1F18:0x2118])[0]
    send = send.decode('utf-16le').split('\0')[0]
    result += print_config("send magic word: %s" % (send))

    # mutex name in injected process (e.g., svchost)
    mutex = unpack("512s", xsetting[0x2118:0x2318])[0]
    mutex = mutex.decode('utf-16le').split('\0')[0]
    result += print_config("mutex name in injected process: %s" % (mutex))

    # screen capture flag
    sc_enabled = unpack("<I", xsetting[0x2318:0x231C])[0]
    result += print_config("screen capture flag: %d" % (sc_enabled))

    # expire days used in http header
    ex_days = unpack("<I", xsetting[0x232C:0x2330])[0]
    result += print_config("expire days used in http header: %d" % (ex_days))

    # the folder path saving screenshots
    scr = unpack("512s", xsetting[0x2330:0x2530])[0]
    scr = scr.decode('utf-16le').split('\0')[0]
    result += print_config("the folder path saving screenshots: %s" % (scr))

    return result

def parse_7AC_config(xsetting):
    num_of_servers = 4
    C2_struct_len = 0xC4
    out = ''

    result = print_config("PlugX config (0x7AC#2)")

    msec_for_WaitForSingleObject = unpack("<I", xsetting[0x8:0xC])[0]
    result += print_config("msec_for_WaitForSingleObject: %d" % (msec_for_WaitForSingleObject))

    for entry in range(num_of_servers):
        offset = 0xC + entry * C2_struct_len
        protocol_flag, port, hostname, username, password = unpack("<HH64s64s64s", xsetting[offset:offset+C2_struct_len])
        hostname = hostname.decode('ascii').split('\0')[0]
        username = username.decode('ascii').split('\0')[0]
        password = password.decode('ascii').split('\0')[0]
        result += print_config("C2 (or Proxy) server entry %d: connection type (only HTTP supported = 1) = %d, hostname = %s, port = %d, proxy username = %s, proxy pasword = %s" % (entry, protocol_flag, hostname, port, username, password))

    service_name = unpack("64s", xsetting[0x6AC:0x6EC])[0]
    service_name = service_name.decode('utf-16le').split('\0')[0]
    result += print_config("service name: %s" % (service_name))
    service_desc = unpack("64s", xsetting[0x6EC:0x72C])[0]
    service_desc = service_desc.decode('utf-16le').split('\0')[0]
    result += print_config("service description: %s" % (service_desc))
    display_name = unpack("64s", xsetting[0x72C:0x76C])[0]
    display_name = display_name.decode('utf-16le').split('\0')[0]
    result += print_config("service display name: %s" % (display_name))

    unk = unpack("64s", xsetting[0x76C:0x7AC])[0]
    unk = unk.decode('utf-16le').split('\0')[0]
    result += print_config("unknown string: %s" % (unk))

    return result

def parse_config(xsetting, len):
    imm.log("parsing config..")

    if len == 0x1D18:
        result = parse_ver4_config(xsetting)
    elif len == 0x150C:
        result = parse_150C_config(xsetting)
    elif len == 0x1510:
        result = parse_1510_config(xsetting)
    elif len == 0x1B18:
        result = parse_1B18_config(xsetting)
    elif len == 0x2540:
        result = parse_2540_config(xsetting)
    elif len == 0x7AC:
        result = parse_7AC_config(xsetting)
    else:
        imm.log("not defined about this version")
        result = None

    if result != None:
        config_file = open(save_path + 'config.txt', 'w')
        config_file.write(result)
        config_file.close()
        imm.log("saved: %s" % (save_path + 'config.txt'))

def decrypt(key, src, size, algorithm):
    dst = b''
    i = 0
    if algorithm == 1:
        key0 = key
        key1 = key
        key2 = key
        key3 = key
        if size > 0:
            while i < size:
                key0 = (key0 + (((key0 >> 3)&0xFFFFFFFF) - 0x11111111)&0xFFFFFFFF)&0xFFFFFFFF
                key1 = (key1 + (((key1 >> 5)&0xFFFFFFFF) - 0x22222222)&0xFFFFFFFF)&0xFFFFFFFF
                key2 = (key2 + (0x44444444 - ((key2 << 9)&0xFFFFFFFF))&0xFFFFFFFF)&0xFFFFFFFF
                key3 = (key3 + (0x33333333 - ((key3 << 7)&0xFFFFFFFF))&0xFFFFFFFF)&0xFFFFFFFF
                new_key = (((key2&0xFF) + (key3&0xFF) + (key1&0xFF) + (key0&0xFF))&0xFF)
                res = unpack("<B", src[i:i+1])[0] ^ new_key
                dst += pack("<B", res)
                i = i + 1
        return dst
    elif algorithm == 2:
        if size > 0:
            while i < size:
                key = ((((key << 7)&0xFFFFFFFF) - ((key >> 3)&0xFFFFFFFF) + i + 1899663297)&0xFFFFFFFF)
                res = key ^ ((key >> 8)&0xFFFFFFFF) ^ ((key >> 16)&0xFFFFFFFF) ^ (unpack("<B", src[i:i+1])[0]) ^ ((key >> 24)&0xFFFFFFFF)
                dst += pack("<B", res&0xFF)
                i += 1
        return dst
    elif algorithm == 3:
        key1 = key
        key2 = key
        key3 = key
        if size > 0:
            while i < size:
                key = (((key + ((key >> 3)&0xFFFFFFFF))&0xFFFFFFFF) + 3)&0xFFFFFFFF
                key1 = (((key1 + ((key1 >> 5)&0xFFFFFFFF))&0xFFFFFFFF) + 5)&0xFFFFFFFF
                key2 = (((key2 -7)&0xFFFFFFFF) - ((key2 << 7)&0xFFFFFFFF))&0xFFFFFFFF
                key3 = (((key3 -9)&0xFFFFFFFF) - ((key3 << 9)&0xFFFFFFFF))&0xFFFFFFFF
                new_key = ((key3&0xFF) + (key2&0xFF) + (key1&0xFF) + (key&0xFF))&0xFF
                res = unpack("<B", src[i:i+1])[0] ^ new_key
                dst += pack("<B", res)
                i += 1
        return dst

def decrypt_packed_string(src, algorithm):
    key = unpack("<I", src[0:4])[0]
    imm.log("decrypting..")
    stage1 = decrypt(key, src, len(src), algorithm)

    #magic = unpack("<I", stage1[4:8])[0]
    #if key != magic:
    uncomp_size = unpack("<I", stage1[8:12])[0]
    payload_size = unpack("<I", stage1[12:16])[0]

    imm.log("src=0x%x, payload=0x%x, uncompressed=0x%x" % (len(src), payload_size, uncomp_size))

    if uncomp_size == 0 or ((payload_size + 0x10) != len(src)) or payload_size > uncomp_size:
        # may be config.bin
        return stage1
    else:
        imm.log("uncompressing..")
        compressed = create_string_buffer(stage1[16:])
        uncompressed = create_string_buffer(uncomp_size)
        final_size = c_ulong(0)
        comp_size = payload_size
        nt.RtlDecompressBuffer(2, uncompressed, uncomp_size, compressed, comp_size, byref(final_size))
        return uncompressed[0:final_size.value]

def decompress_packed_string(src):
    uncomp_size = unpack("<I", src[0:4])[0]
    payload_size = len(src) - 4

    imm.log("src=0x%x, payload=0x%x, uncompressed=0x%x" % (len(src), payload_size, uncomp_size))

    imm.log("uncompressing..")
    compressed = create_string_buffer(src[4:])
    uncompressed = create_string_buffer(uncomp_size)
    final_size = c_ulong(0)
    comp_size = payload_size
    nt.RtlDecompressBuffer(2, uncompressed, uncomp_size, compressed, comp_size, byref(final_size))
    return uncompressed[0:final_size.value]

def output_result(extracted, filename):
    result_file = open(save_path + filename, 'wb')
    result_file.write(extracted)
    result_file.close()
    imm.log("saved: %s" % (save_path + filename))

def dumpX(table, algorithm):
    config_addr = imm.readLong(table + 0x10)
    config_len = imm.readLong(table + 0x14)
    config = imm.readMemory(config_addr, config_len)
    imm.log("config: addr=0x%08X, len=0x%X" % (config_addr, len(config)))
    if H(config) != 0:
        extracted_config = decrypt_packed_string(config, algorithm)
        output_result(extracted_config, "config.bin")
        parse_config(extracted_config, config_len)
    else:
        imm.log("entropy value of config.bin is 0 (DEMO version?). Skip it...")
    imm.log("-----------------------------------------------------")
    pe_addr = imm.readLong(table + 0x8)
    pe_len = imm.readLong(table + 0xC)
    pe = imm.readMemory(pe_addr, pe_len)
    imm.log("original PE: addr=0x%08X, len=0x%X" % (pe_addr, len(pe)))
    if algorithm == 1:
        extracted_pe = decrypt_packed_string(pe, algorithm)
    elif algorithm == 2:
        extracted_pe = decompress_packed_string(pe)
    elif algorithm == 3:
        extracted_pe = decrypt_packed_string(pe, 1) # why still use type I decryption?
    output_result(extracted_pe, "PlugX.PE")

def main(args):
    imm.log("################# PlugX config/PE dumper #################")
    # for type I
    imm.log("searching signature...")
    for table in imm.search(signature):
        if (table & 0xffff == 0) and (table == (imm.readLong(table + 0x1c) & 0xffff0000)):
            imm.log("PlugX encrypt data table address: 0x%08X with GULP signature" % table)
            imm.log("-----------------------------------------------------")
            dumpX(table + 4, 1)
            imm.log("-----------------------------------------------------")
            return "Complete.."
    imm.getMemoryPages()
    candidate_sc = []
    # for type II
    imm.log("searching shellcode (getPC) at section start ...")
    for a in imm.MemoryPages.keys():
        mem = imm.MemoryPages[a]
        start = mem.getBaseAddress()
        get_pc = imm.readMemory(start, 6)
        if get_pc.encode("HEX") == 'e80000000058':
            imm.log("found get PC code at section start(0x%X)" % start)
            candidate_sc.append(start)
    for a in imm.MemoryPages.keys():
        page = imm.MemoryPages[a]
        mem_bin = page.getMemory()
        if not mem_bin:
            continue
        if page.getAccess(human=True) != 'PAGE_EXECUTE_READWRITE':
            continue
        for sc_addr in candidate_sc:
            f = mem_bin.find(pack("L", sc_addr))
            while f != -1:
                #imm.log("find search hit")
                if (f % 4) != 0:
                    f = mem_bin.find(pack("L", sc_addr), f+1, len(mem_bin))
                else:
                    table = a + f
                    ptr1 = imm.readLong(table + 8)
                    ptr2 = imm.readLong(table + 0x10)
                    start = imm.MemoryPages[sc_addr].getBaseAddress()
                    end = start + imm.MemoryPages[sc_addr].getSize()
                    if ptr1 > start and ptr1 < end and ptr2 > start and ptr2 < end:
                        current_process = imm.readLong(table + 0x18)
                        imm.log("current process: %d (0 = installed malware, 2 = 1st injected, 3 = 2nd injected, 4 = iexplore.exe (3rd injected?))" % current_process)
                        imm.log("PlugX encrypt data table address: 0x%08X without GULP signature" % table)
                        imm.log("-----------------------------------------------------")
                        dumpX(table, 2)
                        imm.log("-----------------------------------------------------")
                        return "Complete.."
    # for type 2.5?
    imm.log("searching shellcode (getPC) in all process memory ...")
    ret_list = imm.search("\xe8\x00\x00\x00\x00\x58")
    for ret in ret_list:
        page = imm.getMemoryPageByAddress(ret)
        if page.getAccess(human=True) == 'PAGE_EXECUTE_READWRITE':
            imm.log("found get PC code at 0x%X" % ret)
            candidate_sc.append(ret)
    for a in imm.MemoryPages.keys():
        page = imm.MemoryPages[a]
        mem_bin = page.getMemory()
        if not mem_bin:
            continue
        for sc_addr in candidate_sc:
            f = mem_bin.find(pack("L", sc_addr))
            while f != -1:
                #imm.log("find search hit at 0x%x" % table)
                if (f % 4) != 0:
                    f = mem_bin.find(pack("L", sc_addr), f+1, len(mem_bin))
                else:
                    table = a + f
                    ptr0 = imm.readLong(table)
                    ptr1 = imm.readLong(table + 8)
                    ptr2 = imm.readLong(table + 0x10)
                    #imm.log("0x%x 0x%x 0x%x" % (ptr0, ptr1, ptr2))
                    if (ptr0 & 0xffff0000) == (ptr1 & 0xffff0000) == (ptr2 & 0xffff0000):
                        imm.log("PlugX encrypt data table address in stack: 0x%08X without GULP signature" % table)
                        imm.log("-----------------------------------------------------")
                        dumpX(table, 3)
                        imm.log("-----------------------------------------------------")
                        return "Complete.."

    return "Error: table not found. You should consider to use IDAPython script for more obfuscated variants."


